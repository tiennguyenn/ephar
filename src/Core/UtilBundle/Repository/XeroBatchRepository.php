<?php

namespace UtilBundle\Repository;
use UtilBundle\Entity\XeroSiteBatch;
use UtilBundle\Utility\Constant;

/**
 * XeroBatchRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class XeroBatchRepository extends \Doctrine\ORM\EntityRepository
{
    /**
     * get list batches
     * @param  Request $request
     * @author Bien
     * @modifier thu.tranq
     * @return array
     */
    public function getListBatches($request){
        $search = $request->get('search', '');
        $limit  = $request->get('length', '');
        $start  = $request->get('start', '');
        $end    = $request->get('end', '');
        $status = $request->get('status', '2');
        $sort   = $request->get('sort', array());
        $search = strtolower($search);
        if ($limit == -1) {
            $limit = null;
        }
        $ofset = $request->get('page', 1);

        $query = $this->createQueryBuilder('a');

        if (!empty($search)) {
            $query->leftJoin('a.syncs', 's')
                  ->leftJoin('UtilBundle:XeroJournal', 'xj', 'WITH', 'xj.xeroSyncData = s.id')
                  ->leftJoin('UtilBundle:XeroJournalLine', 'xjl', 'WITH', 'xjl.xeroJournal = xj.id')
                  ->leftJoin('UtilBundle:XeroPayment', 'xp', 'WITH', 'xp.xeroSyncData = s.id')
                  ->leftJoin('UtilBundle:XeroPaymentLine', 'xpl', 'WITH', 'xpl.xeroPayment = xp.id')
                  ->leftJoin('UtilBundle:XeroSale', 'xs', 'WITH', 'xs.xeroSyncData = s.id')
                  ->leftJoin('UtilBundle:XeroSaleLine', 'xsl', 'WITH', 'xsl.xeroSale = xs.id')
                  ->leftJoin('UtilBundle:XeroBill', 'xb', 'WITH', 'xb.xeroSyncData = s.id')
                  ->leftJoin('UtilBundle:XeroBillLine', 'xbl', 'WITH', 'xbl.xeroBill = xb.id');
        }

        switch ($status) {
            case 1:
                $query->where('a.status = 1');
                break;
            case 0:
                $query->where('a.status = 0');
                break;
            default :
                break;
        }
        if (!empty($search)) {
            $query->andWhere('(xjl.gmedsCode like :search or xpl.gmedsCode like :search  or xsl.gmedsCode like :search or xsl.gmedsCode like :search or xbl.gmedsCode like :search)')
                ->setParameter("search", "%$search%");
        }

        if(!empty($start)&& !empty($end)){
            $query->andWhere( $query->expr()->gte('date(a.batchDate)', ':start'))
                    ->andWhere( $query->expr()->lte('date(a.batchDate)', ':end'))
                    ->setParameter("start", $start)
                    ->setParameter("end", $end);
        }
        $query->groupBy('a.id');
        $this->generateSort($query, $sort);

        $totalResult = count($query->getQuery()->getResult());
        $query->setMaxResults($limit)
            ->setFirstResult(($ofset - 1) * $limit);
        $batches = $query->getQuery()->getResult();
        $data = array();
        foreach ($batches as $obj) {
            $siteLabel = '';
            if($obj->getSite()){
                $site = $obj->getSite()->getSiteBatches()->first();
                $siteLabel = $site->getBatchSiteLabel();
            }

            $start     = $obj->getStartTime()->format('d M Y H:i:s');
            $end       = $obj->getEndTime()->format('d M Y H:i:s');
            $createdOn = $obj->getCreatedOn()->format('d M Y');
            $batchDate = empty($obj->getBatchDate())? '' : $obj->getBatchDate()->format('d M Y');
            $status = Constant::LIST_BATCH_STATUS[$obj->getStatus()];
            array_push($data, array(
                    'id'          => $obj->getId(),
                    'start'       => $start,
                    'end'         => $end,
                    'statusLabel' => $status,
                    'status'      => $obj->getStatus(),
                    'createdOn'   => $createdOn,
                    'batchDate'   => $batchDate,
                    'site' => $siteLabel

                )
            );
        }


        return array('data' => $data, 'total' => $totalResult);
    }
    private function generateSort($em, $data) {
        foreach ($data as $key => $value) {
            switch ($key) {
                case 'startTime':
                    $em->orderBy("a.startTime", $value);
                    break;
                case 'endTime':
                    $em->orderBy("a.endTime", $value);

                    break;
                case 'status':
                    $em->orderBy("a.status", $value);
                    break;
                case 'batchDate':
                    $em->orderBy("a.batchDate", $value);
                    break;


            }
        }
    }
}