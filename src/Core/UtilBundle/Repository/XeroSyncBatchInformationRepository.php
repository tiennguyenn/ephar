<?php

namespace UtilBundle\Repository;

use Doctrine\DBAL\Connection;
use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\QueryBuilder;
use DoctrineExtensions\Query;
use UtilBundle\Entity\XeroSyncBatchInformation;
use UtilBundle\Utility\Common;
use UtilBundle\Utility\Constant;

/**
 * XeroSyncBatchInformationRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class XeroSyncBatchInformationRepository extends EntityRepository
{
    /**
    * create new
    */
    public function create($params)
    {
        $obj = new XeroSyncBatchInformation();
        $obj->setAccountName($params['accountName']);
        $obj->setDocumentType($params['documentType']);
        $obj->setStatusTransfer($params['statusTransfer']);
        $obj->setXeroSyncBatch($params['xeroSyncBatch']);
        $obj->setCreatedOn(new \DateTime());

        $em = $this->getEntityManager();
        $em->persist($obj);
        $em->flush();

        return $obj;
    }

    /**
     * update
     */
    public function update($params)
    {
        $obj = $this->findOneBy(array('id' => $params['id']));
        if( null == $obj )
            return null;

        $obj->setPoWeekly($params['poWeekly']);

        $em = $this->getEntityManager();
        $em->persist($obj);
        $em->flush();

        return $obj;
    }

    /**
     * get list
     */
    public function getListBy($params)
    {
        if(!empty($params['start_date'])) {
            $start = new \DateTime($params['start_date']);
            $end = new \DateTime($params['end_date']);
        } else {
            $start = new \DateTime();
            $start = $start->modify("-1 month");
            $end = new \DateTime();
        }

        $qb = $this->getEntityManager()->createQueryBuilder();
        $qb->select("s.id, s.accountName, s.documentType, s.statusTransfer, s.createdOn")
           ->from('UtilBundle:XeroSyncBatchInformation', 's')
           ->andWhere('s.createdOn >= :start AND s.createdOn <= :end')
           ->setParameter('start', $start->format("Y-m-d 00:00:00"))
           ->setParameter('end', $end->format("Y-m-d 11:59:59"));
       
        if(isset($params['status']) && $params['status'] != 'all') {
            $qb->andWhere('s.statusTransfer = :status')
            ->setParameter('status', $params['status']);
        }

        //count total items
        $totalResult = count($qb->getQuery()->getArrayResult());

        if(isset($params['sorting']) && !empty($params['sorting'])){
            $arrSort= explode("_", $params['sorting']);
            if(isset($arrSort[0]) && isset($arrSort[1])) {
                $qb->orderBy('s.'.$arrSort[0], strtoupper($arrSort[1]));
            }
        } else {
            $qb->orderBy('s.createdOn', 'DESC');
        }

        //pagination
        $perPage = ($params['perPage'] > 0)? $params['perPage']: Constant::PER_PAGE_DEFAULT;
        $page = ($params['page'] > 0)? $params['page']: Constant::PAGE_DEFAULT;

        $qb->setFirstResult($perPage*$page)->setMaxResults($perPage);

        return array(
            'totalResult' => $totalResult,
            'totalPages'  => ceil($totalResult/$perPage),
            'data'        => $qb->getQuery()->getArrayResult()
        );
    }
}