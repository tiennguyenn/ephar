<?php

namespace UtilBundle\Repository;
use UtilBundle\Entity\XeroMapping;
use UtilBundle\Entity\XeroPaymentLine;
use UtilBundle\Utility\Constant;

/**
 * XeroSyncDataRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class XeroSyncDataRepository extends \Doctrine\ORM\EntityRepository
{

  /**
   * syn order detail
   * @param  $request
   * @author thu.tranq
   * @return array
   */
    public function getOrderData($request) {
        $id       = $request->get('lineId', '');
        $type     = $request->get('lineType', '');
        
        $limit        = $request->get('length', '');
        $sort         = $request->get('sort', array());
        $filterByDest = $request->get('filterByDest', '');
        $isDownload = $request->get('isDownload', false);


        if ($limit == -1) {
            $limit = null;
        }
        $ofset = $request->get('page', 1);

        $em   = $this->getEntityManager();
        if ($type == Constant::XERO_DOCUMENT_TYPE_JOURNAL) {
          $selectStr = "ls.calculatedAmountCredit as amt1, ls.calculatedAmountDebit as amt2, ";
        } else {
          $selectStr = "ls.calculatedAmount as amt1, ls.calculatedAmount as amt2, ";
        }
        $selectStr .= 'rx.orderNumber as rxInvoiceId, 
                      cac.code as cCode, 
                      dac.code as dCode, 
                      cac.name as cDescription, 
                      dac.name as dDescription';
        switch ($type) {
          case Constant::XERO_DOCUMENT_TYPE_SALE:
            $lineRepo = $em->getRepository('UtilBundle:XeroSaleLineSource');
            $query    = $lineRepo->createQueryBuilder('ls');
            $query->select($selectStr);
            $query->innerJoin('ls.xeroSaleLine', 'l');
            break;
          case Constant::XERO_DOCUMENT_TYPE_BILL:
            $lineRepo = $em->getRepository('UtilBundle:XeroBillLineSource');
            $query    = $lineRepo->createQueryBuilder('ls');
            $query->select($selectStr);
            $query->innerJoin('ls.xeroBillLine', 'l');
            break;
          case Constant::XERO_DOCUMENT_TYPE_JOURNAL:
            $lineRepo = $em->getRepository('UtilBundle:XeroJournalLineSource');
            $query    = $lineRepo->createQueryBuilder('ls');
            $query->select($selectStr);
            $query->innerJoin('ls.xeroJournalLine', 'l');
            break;
          case Constant::XERO_DOCUMENT_TYPE_PAYMENT:
                $result = $this->getPaymentRxLineSource($id, $limit, ($ofset - 1) * $limit, $isDownload);
                return $result;
            break;
          
          default:
            # code...
            break;
        }
        $query->innerJoin('ls.rx', 'rx')
              ->leftJoin('l.xeroMapping', 'xm')
              ->leftJoin('xm.creditAccountCode', 'cac')
              ->leftJoin('xm.debitAccountCode', 'dac')
              ->where('l.id = :id')
              ->setParameter('id', $id);

        if (!empty($filterByDest)) {
            if ((int)$filterByDest == Constant::XERO_MAPPING_ALL) { // all
                $query->andWhere('xm.orderDestination = :local or xm.orderDestination = :overseas' )
                      ->setParameter("local", Constant::XERO_MAPPING_LOCAL)
                      ->setParameter("overseas", Constant::XERO_MAPPING_OVERSEAS);
            } else {
                $query->andWhere('xm.orderDestination = :dest')
                      ->setParameter("dest", $filterByDest);
            }
        }

        $this->generateSort($query, $sort);

        $totalResult = 0;

        if (!$isDownload) {
          $totalResult = count($query->getQuery()->getResult());
          $query->setMaxResults($limit)
              ->setFirstResult(($ofset - 1) * $limit);
        }
        $data = $query->getQuery()->getArrayResult();

        return array('data' => $data, 'total' => $totalResult);
    }

    private function getPaymentRxLineSource($paymentLineId, $limit, $offset, $isDownload= false){
        $result = array('data' => [], 'total' => []);
        $em   = $this->getEntityManager();
        $paymentLine = $em->getRepository('UtilBundle:XeroPaymentLine')->find($paymentLineId);

        $paymentSyncData = $paymentLine->getXeroPayment()->getXeroSyncData();

        if(!empty($paymentSyncData)){
            $objMapping = $paymentLine->getXeroMapping();
            $sources = $paymentLine->getSources();
            $result['total'] = count($sources);
          //  var_dump(count($sources),$limit, $offset);exit;
            $i = 0;
            $count = 0;
            $data = [];
            //var_dump($offset,$limit, $isDownload);exit;
            if (!$isDownload) {
                foreach ($sources as $source){
                    if ($i >= $offset && $count < $limit) {
                        $objData =[
                            'amt2'  => $source->getCalculatedAmount(),
                            'amt1' => $source->getCalculatedAmount(),
                            'id' => $source->getId(),
                            'rxInvoiceId' => $source->getRx()->getOrderNumber(),
                        ];
                        $cCode = $objMapping->getCreditAccountCode();
                        $dCode = $objMapping->getDebitAccountCode();

                        $objData['cCode'] = '';
                        $objData['cDescription'] = '';
                        $objData['dCode'] = '';
                        $objData['dDescription'] = '';

                        $cCode = $objMapping->getCreditAccountCode();
                        if (isset($cCode)) {
                          $objData['cCode'] = $cCode->getCode();
                          $objData['cDescription'] = $cCode->getName();
                        }

                        $dCode = $objMapping->getDebitAccountCode();
                        if (isset($dCode)) {
                          $objData['dCode'] = $dCode->getCode();
                          $objData['dDescription'] = $dCode->getName();
                        }
                            $data[] = $objData;
                            $count++;
                        }
                    $i++;

                }
            } else {
                foreach ($sources as $source){
                    $objData = [
                            'amt2'  => $source->getCalculatedAmount(),
                            'amt1' => $source->getCalculatedAmount(),
                            'id' => $source->getId(),
                            'rxInvoiceId' => $source->getRxInvoiceId(),

                    ];
                        $objData['cCode'] = '';
                        $objData['cDescription'] = '';
                        $objData['dCode'] = '';
                        $objData['dDescription'] = '';

                        $cCode = $objMapping->getCreditAccountCode();
                        if (isset($cCode)) {
                          $objData['cCode'] = $cCode->getCode();
                          $objData['cDescription'] = $cCode->getName();
                        }

                        $dCode = $objMapping->getDebitAccountCode();
                        if (isset($dCode)) {
                          $objData['dCode'] = $dCode->getCode();
                          $objData['dDescription'] = $cCode->getName();
                        }
                    
                    $data[] = $objData;
                }

            }
            $result['data'] = $data;
        }

        return $result;
    }


    /**
     * get data for Download Excel Report on Batch Info page
     * @param  Object $request
     * @return array
     */
    public function getBatchInfoDataForExcelReport($request) {
        $data = array();
        $request->set('isDownload', true);
        $batchId = $request->get('id');
        $query = $this->createQueryBuilder('s');
        $query->select('s.id')
              ->where('s.xeroBatch = :batchId')
              ->setParameter("batchId", $batchId);

        $syncDatas = $this->getListSyncBatches($request);
        foreach ($syncDatas['data'] as $sync) {
            $request->set('id', $sync['id']);
            $tmp     = $this->getBatchDetailData($request);
            foreach ($tmp['data'] as $k => $val) {
              $val['accountName']  = $sync['accountName'];
              $val['documentType'] = $sync['documentType'];
              $val['documentDate'] = $sync['createdOn'];
              $val['status']       = ($sync['status'] == true) ? 'Transferred' :  'Error';
              $val['transferDate'] = $sync['createdOn'];
              $tmp['data'][$k] = $val;
            }
            $tmp     = $tmp['data'];
            $data = array_merge($data, $tmp);
        }

        return $data;
    }

    /**
     * get batch detail
     * @param  Request $request
     * @return array
     */
    public function getBatchDetailData($request){
        $id      = $request->get('id', '');
        $batchId = $request->get('batchId');

        $em        = $this->getEntityManager();
        // get xero sync data
        $syncData = $em->getRepository('UtilBundle:XeroSyncData')->find((int)$id);
        // get xero document type
        $xeroDocumentType = $syncData->getXeroDocumentType()->getName();

        $search       = $request->get('search', '');
        $limit        = $request->get('length', '');
        $id           = $request->get('id', '');
        $sort         = $request->get('sort', array());
        $search       = strtolower($search);
        $filterByDest = $request->get('filterByDest', '');

        if ($limit == -1) {
            $limit = null;
        }
        $ofset = $request->get('page', 1);
        if(empty($id)){
            return [];
        }
        // build queryBuiler
        $query = $this->createQueryBuilder('s');
        $selectStr = "l.gmedsCode as gmedsCode, l.id as lineId,
                     cac.code as cCode,
                     cac.name as cDescription,
                     dac.code as dCode,
                     dac.name as dDescription,
                     DATE_FORMAT(s.createdOn, '%d %M %Y') as createdOn
            ";
        if ($xeroDocumentType == Constant::XERO_DOCUMENT_TYPE_JOURNAL) {
            // for journal
            $selectStr .= ", ABS(l.creditAmount) as creditAmount,
                     ABS(l.debitAmount) as debitAmount";
        } else {
            $selectStr .= ", ABS(l.amount) as creditAmount,
                     ABS(l.amount) as debitAmount";
        }
        $saleType    = Constant::XERO_DOCUMENT_TYPE_SALE;
        $billType    = Constant::XERO_DOCUMENT_TYPE_BILL;
        $journalType = Constant::XERO_DOCUMENT_TYPE_JOURNAL;
        $paymentType = Constant::XERO_DOCUMENT_TYPE_PAYMENT;
        switch ($xeroDocumentType) {
            case $saleType:
                $selectStr .= ", '{$saleType}' as lineType, xs.reference as narration";

                break;
            case $billType:
                $selectStr .= ", '{$billType}' as lineType, xb.reference as narration";
                break;
            case $journalType:
                $selectStr .= ", '{$journalType}' as lineType, xj.reference as narration";
                break;
            case $paymentType:
                $selectStr .= ", '{$paymentType}' as lineType, xp.reference as narration";
                break;
            default:
                # code...
                break;
        }

        $query->select($selectStr);
        switch ($xeroDocumentType) {
            case Constant::XERO_DOCUMENT_TYPE_SALE:
                $query->leftJoin('s.sales', 'xs')
                      ->leftJoin('xs.lines', 'l')
                      ->leftJoin('l.xeroMapping', 'xm')
                      ->leftJoin('xm.creditAccountCode', 'cac')
                      ->leftJoin('xm.debitAccountCode', 'dac');
                break;
            case Constant::XERO_DOCUMENT_TYPE_BILL:
                $query->leftJoin('s.bills', 'xb')
                      ->leftJoin('xb.lines', 'l')
                      ->leftJoin('l.xeroMapping', 'xm')
                      ->leftJoin('xm.creditAccountCode', 'cac')
                      ->leftJoin('xm.debitAccountCode', 'dac');
                break;
            case Constant::XERO_DOCUMENT_TYPE_JOURNAL:
                $query->leftJoin('s.journals', 'xj')
                      ->leftJoin('xj.lines', 'l')
                      ->leftJoin('l.xeroMapping', 'xm')
                      ->leftJoin('xm.creditAccountCode', 'cac')
                      ->leftJoin('xm.debitAccountCode', 'dac');
                break;
            case Constant::XERO_DOCUMENT_TYPE_PAYMENT:
                $query->leftJoin('s.payments', 'xp')
                      ->leftJoin('xp.lines', 'l')
                      ->leftJoin('l.xeroMapping', 'xm')
                      ->leftJoin('xm.creditAccountCode', 'cac')
                      ->leftJoin('xm.debitAccountCode', 'dac');
                break;
            default:
                # code...
                break;
        }


              
        $query->where('s.id = '.$id);

        // FILTER BY GMEDES CODE
        if (!empty($search)) {
            $query->andWhere('l.gmedsCode like :search')
                  ->setParameter("search", "%$search%");
        }
        // filter by destination
        if (!empty($filterByDest)) {
            if ((int)$filterByDest == Constant::XERO_MAPPING_ALL) { // all
                $query->andWhere('xm.orderDestination = :local or xm.orderDestination = :overseas' )
                      ->setParameter("local", Constant::XERO_MAPPING_LOCAL)
                      ->setParameter("overseas", Constant::XERO_MAPPING_OVERSEAS);
            } else {
                $query->andWhere('xm.orderDestination = :dest')
                      ->setParameter("dest", $filterByDest);
            }
        }
        $this->generateSort($query, $sort);

        $totalResult = 0;
        $isDownload = $request->get('isDownload', false);
        if (!$isDownload) {
          $totalResult = count($query->getQuery()->getResult());
          $query->setMaxResults($limit)
              ->setFirstResult(($ofset - 1) * $limit);
        }

        $data = $query->getQuery()->getArrayResult();


        return array('data' => $data, 'total' => $totalResult);
    }

    /**
     * getListSyncBatches 
     * @param  Request $request
     * @return array
     */
    public function getListSyncBatches($request){
        $statuses     = Constant::LIST_BATCH_STATUS;
        $search       = $request->get('search', '');
        $limit        = $request->get('length', '');
        $id           = $request->get('id', '');
        $status       = $request->get('status', '2');
        $sort         = $request->get('sort', array());
        $search       = strtolower($search);
        $filterByDest = $request->get('filterByDest', '5');
        $local = Constant::XERO_MAPPING_LOCAL;
        $overseas = Constant::XERO_MAPPING_OVERSEAS;

        if ($limit == -1) {
            $limit = null;
        }
        $ofset = $request->get('page', 1);
        if(empty($id)){
            return [];
        }



        $query = $this->createQueryBuilder('s');
        $query->select("s.id, xdt.friendlyName as documentType, 
                        s.payee as accountName, 
                        b.status, 
                        s.id as syncDataId, DATE_FORMAT(s.createdOn, '%d %M %Y') as createdOn,
                        b.id as batchId,
                        xm1.tlrColumn as tlrColumn1,
                        xm2.tlrColumn as tlrColumn2,
                        xm3.tlrColumn as tlrColumn3,
                        xm4.tlrColumn as tlrColumn4,
                        s.isSynced as status,
                          CONCAT(
                            CASE 
                                WHEN xm1.orderDestination = {$local} THEN 'Local'
                                WHEN xm1.orderDestination = {$overseas} THEN 'Overseas'
                                ELSE ''
                            END , 
                            CASE 
                                WHEN xm2.orderDestination = {$local} THEN 'Local'
                                WHEN xm2.orderDestination = {$overseas} THEN 'Overseas'
                                ELSE ''
                            END, 
                            CASE 
                                WHEN xm3.orderDestination = {$local} THEN 'Local'
                                WHEN xm3.orderDestination = {$overseas} THEN 'Overseas'
                                ELSE ''
                            END,
                            CASE 
                                WHEN xm4.orderDestination = {$local} THEN 'Local'
                                WHEN xm4.orderDestination = {$overseas} THEN 'Overseas'
                                ELSE ''
                            END
                          ) as orderDes
                        ")
              ->innerJoin('s.xeroBatch', 'b');

        // if (!empty($search)) {
         $query->leftJoin('UtilBundle:XeroDocumentType', 'xdt', 'WITH', 'xdt.id = s.xeroDocumentType');

         $query->leftJoin('UtilBundle:XeroJournal', 'xj', 'WITH', 'xj.xeroSyncData = s.id')
              ->leftJoin('UtilBundle:XeroJournalLine', 'xjl', 'WITH', 'xjl.xeroJournal = xj.id')
              ->leftJoin('UtilBundle:XeroMapping', 'xm1', 'WITH', 'xm1.id = xjl.xeroMapping')
              ->leftJoin('UtilBundle:XeroPayment', 'xp', 'WITH', 'xp.xeroSyncData = s.id')
              ->leftJoin('UtilBundle:XeroPaymentLine', 'xpl', 'WITH', 'xpl.xeroPayment = xp.id')
               ->leftJoin('UtilBundle:XeroMapping', 'xm2', 'WITH', 'xm2.id = xpl.xeroMapping')
              ->leftJoin('UtilBundle:XeroSale', 'xs', 'WITH', 'xs.xeroSyncData = s.id')
              ->leftJoin('UtilBundle:XeroSaleLine', 'xsl', 'WITH', 'xsl.xeroSale = xs.id')
               ->leftJoin('UtilBundle:XeroMapping', 'xm3', 'WITH', 'xm3.id = xsl.xeroMapping')
              ->leftJoin('UtilBundle:XeroBill', 'xb', 'WITH', 'xb.xeroSyncData = s.id')
              ->leftJoin('UtilBundle:XeroBillLine', 'xbl', 'WITH', 'xbl.xeroBill = xb.id')
              ->leftJoin('UtilBundle:XeroMapping', 'xm4', 'WITH', 'xm4.id = xbl.xeroMapping');
              
        $query->where('b.id = '.$id);

        if (!empty($search)) {
            $query->andWhere('(xjl.gmedsCode like :search or xpl.gmedsCode like :search  or xsl.gmedsCode like :search or xsl.gmedsCode like :search or xbl.gmedsCode like :search)')
                ->setParameter("search", "%$search%");
        }

        switch ($status) {
            case 1:
                $query->andWhere('s.isSynced = 1');
                break;
            case 0:
                $query->andWhere('s.isSynced = 0');
                break;
            default :
                break;
        }

        // FILTER BY DESTINATION LOCAL/OVERESA
        if (!empty($filterByDest)) {
            if ((int)$filterByDest == Constant::XERO_MAPPING_ALL) { // all
                $query->andWhere('(
                                    xm1.orderDestination = :local or xm1.orderDestination = :overseas or
                                    xm2.orderDestination = :local or xm2.orderDestination = :overseas or
                                    xm3.orderDestination = :local or xm3.orderDestination = :overseas or
                                    xm4.orderDestination = :local or xm4.orderDestination = :overseas
                                )' )
                      ->setParameter("local", Constant::XERO_MAPPING_LOCAL)
                      ->setParameter("overseas", Constant::XERO_MAPPING_OVERSEAS);
            } else {
                $query->andWhere('(
                                xm1.orderDestination = :dest or
                                xm2.orderDestination = :dest or
                                xm3.orderDestination = :dest or
                                xm4.orderDestination = :dest
                        )')
                      ->setParameter("dest", $filterByDest);
            }
            $query->groupBy('s.id');
        }

        $query->groupBy('s.id');


        $this->generateSort($query, $sort);

        $totalResult = 0;
        $isDownload = $request->get('isDownload', false);
        if (!$isDownload) {
          $totalResult = count($query->getQuery()->getResult());
          $query->setMaxResults($limit)
              ->setFirstResult(($ofset - 1) * $limit);
        }

        $data = $query->getQuery()->getArrayResult();

        return array('data' => $data, 'total' => $totalResult);
    }

    public function getSingleSyncBatches($id){
        $bath = $this->find($id);
        $status = Constant::LIST_BATCH_STATUS[$bath->getIsSynced()];
        $lastRetryOn = $bath->getLastRetryOn();
        $result = [
             'name'=> '',
             'document'=> '',
             'date' => isset($lastRetryOn) ? $lastRetryOn->format(Constant::GENERAL_DATE_FORMAT) : '',
             'data' => stream_get_contents($bath->getXmldoc()),
             'status' => $status
        ];
        return $result;
    }


    private function generateSort($em, $data) {
        foreach ($data as $key => $value) {
            switch ($key) {
                case 'documentType':
                    $em->orderBy("documentType", $value);
                    break;
                case 'accountName':
                    $em->orderBy("accountName", $value);
                    break;
                case 'status':
                    $em->orderBy("status", $value);
                    break;
                case 'gmedsCode':
                    $em->orderBy("gmedsCode", $value);
                    break;
                case 'rxInvoiceId':
                    $em->orderBy("rxInvoiceId", $value);
                    break;
                case 'narration':
                    $em->orderBy("narration", $value);
                    break;
                case 'region':
                    $em->orderBy("orderDes", $value);
                    break;
            }
        }
    }

    /**
     * get batch detail
     */
    public function getBatchDetailDataToFile($id)
    {
        $em        = $this->getEntityManager();
        // get xero sync data
        $syncData = $em->getRepository('UtilBundle:XeroSyncData')->find((int)$id);
        // get xero document type
        $xeroDocumentType = $syncData->getXeroDocumentType()->getName();

        $documentType = array(
            'name' => $syncData->getXeroDocumentType()->getName(),
            'friendlyName' => $syncData->getXeroDocumentType()->getFriendlyName()
        );

        // build queryBuiler
        $query = $this->createQueryBuilder('s');
        $selectStr = "l.gmedsCode as gmedsCode, l.id as lineId,
                     cac.code as cCode,
                     cac.name as cDescription,
                     dac.code as dCode,
                     dac.name as dDescription,
                     DATE_FORMAT(s.createdOn, '%d %M %Y') as createdOn
            ";
        if ($xeroDocumentType == Constant::XERO_DOCUMENT_TYPE_JOURNAL) {
            // for journal
            $selectStr .= ", l.creditAmount as creditAmount,
                     l.debitAmount as debitAmount";
        } else {
            $selectStr .= ", l.amount as creditAmount,
                     l.amount as debitAmount";
        }
        $saleType    = Constant::XERO_DOCUMENT_TYPE_SALE;
        $billType    = Constant::XERO_DOCUMENT_TYPE_BILL;
        $journalType = Constant::XERO_DOCUMENT_TYPE_JOURNAL;
        $paymentType = Constant::XERO_DOCUMENT_TYPE_PAYMENT;
        switch ($xeroDocumentType) {
            case $saleType:
                $selectStr .= ", '{$saleType}' as lineType";
                break;
            case $billType:
                $selectStr .= ", '{$billType}' as lineType";
                break;
            case $journalType:
                $selectStr .= ", '{$journalType}' as lineType";
                break;
            case $paymentType:
                $selectStr .= ", '{$paymentType}' as lineType";
                break;
            default:
                # code...
                break;
        }

        $query->select($selectStr);
        switch ($xeroDocumentType) {
            case Constant::XERO_DOCUMENT_TYPE_SALE:
                $query->leftJoin('s.sales', 'xs')
                    ->leftJoin('xs.lines', 'l')
                    ->leftJoin('l.xeroMapping', 'xm')
                    ->leftJoin('xm.creditAccountCode', 'cac')
                    ->leftJoin('xm.debitAccountCode', 'dac');
                break;
            case Constant::XERO_DOCUMENT_TYPE_BILL:
                $query->leftJoin('s.bills', 'xb')
                    ->leftJoin('xb.lines', 'l')
                    ->leftJoin('l.xeroMapping', 'xm')
                    ->leftJoin('xm.creditAccountCode', 'cac')
                    ->leftJoin('xm.debitAccountCode', 'dac');
                break;
            case Constant::XERO_DOCUMENT_TYPE_JOURNAL:
                $query->leftJoin('s.journals', 'xj')
                    ->leftJoin('xj.lines', 'l')
                    ->leftJoin('l.xeroMapping', 'xm')
                    ->leftJoin('xm.creditAccountCode', 'cac')
                    ->leftJoin('xm.debitAccountCode', 'dac');
                break;
            case Constant::XERO_DOCUMENT_TYPE_PAYMENT:
                $query->leftJoin('s.payments', 'xp')
                    ->leftJoin('xp.lines', 'l')
                    ->leftJoin('l.xeroMapping', 'xm')
                    ->leftJoin('xm.creditAccountCode', 'cac')
                    ->leftJoin('xm.debitAccountCode', 'dac');
                break;
            default:
                # code...
                break;
        }



        $query->where('s.id = '.$id);

        // FILTER BY GMEDES CODE
        if (!empty($search)) {
            $query->andWhere('l.gmedsCode like :search')
                ->setParameter("search", "%$search%");
        }
        // filter by destination
        if (!empty($filterByDest)) {
            if ((int)$filterByDest == Constant::XERO_MAPPING_ALL) { // all
                $query->andWhere('xm.orderDestination = :local or xm.orderDestination = :overseas' )
                    ->setParameter("local", Constant::XERO_MAPPING_LOCAL)
                    ->setParameter("overseas", Constant::XERO_MAPPING_OVERSEAS);
            } else {
                $query->andWhere('xm.orderDestination = :dest')
                    ->setParameter("dest", $filterByDest);
            }
        }
        $this->generateSort($query, array());

        $totalResult = 0;

        $data = $query->getQuery()->getArrayResult();

        return array('data' => $data, 'documentType' => $documentType);
    }

}