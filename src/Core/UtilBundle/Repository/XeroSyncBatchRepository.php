<?php

namespace UtilBundle\Repository;

use Doctrine\DBAL\Connection;
use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\QueryBuilder;
use DoctrineExtensions\Query;
use UtilBundle\Entity\XeroSyncBatch;
use UtilBundle\Utility\Common;
use UtilBundle\Utility\Constant;

/**
 * XeroSyncBatchRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class XeroSyncBatchRepository extends EntityRepository
{
    /**
    * create new
    */
    public function create()
    {
        $sync = new XeroSyncBatch();
        $sync->setStartTime(new \DateTime());
        $sync->setEndTime(new \DateTime());
        $sync->setStatusTransfer(1);
        $sync->setCreatedOn(new \DateTime());

        $em = $this->getEntityManager();
        $em->persist($sync);
        $em->flush();

        return $sync;
    }

    /**
     * update
     */
    public function update($params)
    {
        $sync = $this->findOneBy(array('id' => $params['id']));
        if( null == $sync )
            return null;

        $em = $this->getEntityManager();
        $em->persist($sync);
        $em->flush();

        return $sync;
    }

    /**
     * get list
     */
    public function getListBy($params)
    {
        if(!empty($params['start_date'])) {
            $start = new \DateTime($params['start_date']);
            $end = new \DateTime($params['end_date']);
        } else {
            $start = new \DateTime();
            $start = $start->modify("-1 month");
            $end = new \DateTime();
        }
        
        $qb = $this->getEntityManager()->createQueryBuilder();
        $qb->select("s.id, s.startTime, s.endTime, s.statusTransfer, s.createdOn")
            ->from('UtilBundle:XeroSyncBatch', 's')
            ->andWhere('s.startTime >= :start AND s.endTime <= :end')
            ->setParameter('start', $start->format("Y-m-d 00:00:00"))
            ->setParameter('end', $end->format("Y-m-d 11:59:59"));
      
        if(isset($params['status']) && $params['status'] != 'all') {
            $qb->andWhere('s.statusTransfer = :status')
            ->setParameter('status', $params['status']);
        }

        //count total items
        $totalResult = count($qb->getQuery()->getArrayResult());

        if(isset($params['sorting']) && !empty($params['sorting'])){
            $arrSort= explode("_", $params['sorting']);
            if(isset($arrSort[0]) && isset($arrSort[1])) {
                $qb->orderBy('s.'.$arrSort[0], strtoupper($arrSort[1]));
            }
        } else {
            $qb->orderBy('s.createdOn', 'DESC');
        }

        //pagination
        $perPage = ($params['perPage'] > 0)? $params['perPage']: Constant::PER_PAGE_DEFAULT;
        $page = ($params['page'] > 0)? $params['page']: Constant::PAGE_DEFAULT;

        $qb->setFirstResult($perPage*$page)->setMaxResults($perPage);

        return array(
            'totalResult' => $totalResult,
            'totalPages'  => ceil($totalResult/$perPage),
            'data'        => $qb->getQuery()->getArrayResult()
        );
    }
}